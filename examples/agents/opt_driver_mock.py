import json
from time import sleep
import random
from typing import Dict, List

from flowcept.flowcept_api.flowcept_controller import Flowcept
from flowcept.flowceptor.consumers.agent.client_agent import run_tool, run_tool_async
from flowcept.flowceptor.consumers.base_consumer import BaseConsumer
from flowcept.instrumentation.flowcept_task import flowcept_task

try:
    print(run_tool("check_liveness"))
except Exception as e:
    print(e)
    pass


# class AdamantineDriver(BaseConsumer):
#
#     def __init__(self, number_of_options, max_layers, planned_control: List[Dict], first_layer_ix: int = 2):
#         super().__init__()
#         self._layers_count = 0
#         self._number_of_options = number_of_options
#         self._max_layers = max_layers
#         self._first_layer_ix = first_layer_ix
#         self._planned_control = planned_control
#
#     def message_handler(self, msg_obj: Dict) -> bool:
#         if msg_obj.get('type', '') == 'task':
#             print(msg_obj)
#
#             if msg_obj.get("subtype", '') == "llm_query":
#                 print("Msg from agent.")
#
#                 msg_output = msg_obj.get("generated", {})["response"]
#
#                 simulation_output = simulate_layer(self.layers_count, msg_output)
#
#                 run_tool_async("ask_agent", simulation_output)
#
#         else:
#             print(f"We got a msg with different type: {msg_obj.get("type", None)}")
#         return True






def generate_mock_planned_control(config, number_of_options):
    planned_controls = []
    for i in range(config["max_layers"]):
        possible_options = generate_control_options(number_of_options)
        planned_controls.append(possible_options[random.randint(0, len(possible_options) - 1)])
    print(json.dumps(planned_controls, indent=2))
    return planned_controls


def generate_control_options(number_of_options):
    dwell_arr = list(range(10, 121, 5))
    control_options = []
    for k in range(number_of_options):
        control_options.append({
            "power": random.randint(0, 350),
            "dwell_0": dwell_arr[random.randint(0, len(dwell_arr) - 1)],
            "dwell_1": dwell_arr[random.randint(0, len(dwell_arr) - 1)],
        })
    return control_options


def parse_generate_options_set(control_options_from_agent: List[str])->List[Dict]:
    options_set = []
    for o in control_options_from_agent:
        options_set.append(json.loads(o))
    return options_set


@flowcept_task
def simulate_layer(layer_number: int, control_options: List[Dict]):

    def forward_simulation(_control_option: Dict) -> float:
        """Calculate a score (n2 norm) for a given control_option"""
        assert len(_control_option) == 3
        sleep(0.1)
        return random.randint(0, 100)

    print(f"Simulating for layer {layer_number}")
    print(f"These are the input control options (generated by the agent): {control_options}")
    # Simulation for layer i, i>=2:
    l2_error = []
    for control_option in control_options:
        l2_error.append(forward_simulation(control_option))

    print(f"These are scores calculated by this simulation for these options: {l2_error}")
    return l2_error




#



def adaptive_control_workflow(config):
    number_of_options = config["number_of_options"]
    planned_controls = generate_mock_planned_control(config, number_of_options)

    tool_result = run_tool("generate_options_set", kwargs={
        "layer": 2,
        "planned_controls": planned_controls,
        "number_of_options": number_of_options
    })
    control_options = parse_generate_options_set(tool_result)

    for i in range(2, config["max_layers"]):
        l2_error = simulate_layer(layer_number=i, control_options=control_options)

        tool_result = run_tool("choose_option", kwargs={"l2_error": l2_error, "planned_controls": planned_controls})
        option = int(tool_result[0])
        print(f"Agent chose option {option}: {control_options[option]}. Reason: argmin")

        control_options = run_tool("generate_options_set", kwargs={
            "layer": i+1,
            "planned_controls": planned_controls,
            "number_of_options": number_of_options
        })
        control_options = parse_generate_options_set(control_options)
        print("\n\n")





if __name__ == "__main__":

    config = {"max_layers": 5, "number_of_options": 4}

    with Flowcept(start_persistence=False, save_workflow=False, check_safe_stops=False):
        adaptive_control_workflow(config)
